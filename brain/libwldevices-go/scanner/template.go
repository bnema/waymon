package scanner

// protocolTemplate is the main template for generating Go bindings
const protocolTemplate = `// Code generated by wayland-scanner. DO NOT EDIT.
// Protocol: {{.Protocol}}

package {{.Package}}

import (
{{range .Imports}}	"{{.}}"
{{end}}
)

// Fixed represents a 24.8 fixed-point number
type Fixed int32

// Float64 converts a Fixed to float64
func (f Fixed) Float64() float64 {
	return float64(f) / 256.0
}

// NewFixed creates a Fixed from a float64
func NewFixed(v float64) Fixed {
	return Fixed(v * 256.0)
}

// WaylandObject is the base interface for all Wayland objects
type WaylandObject interface {
	ID() uint32
	SetID(uint32)
	Interface() string
	Version() uint32
}

// Connection represents a Wayland connection
type Connection struct {
	// Socket file descriptor
	fd int
	
	// Object registry
	objects   map[uint32]WaylandObject
	objectsMu sync.RWMutex
	
	// ID allocation
	nextID uint32
	idMu   sync.Mutex
	
	// Message handling
	sendBuf bytes.Buffer
	recvBuf bytes.Buffer
	sendMu  sync.Mutex
	recvMu  sync.Mutex
	
	// Error handling
	lastError error
	errorMu   sync.RWMutex
}

// NewConnection creates a new Wayland connection
func NewConnection() (*Connection, error) {
	// Connect to Wayland socket
	socketPath := os.Getenv("WAYLAND_DISPLAY")
	if socketPath == "" {
		socketPath = "wayland-0"
	}
	
	if !strings.HasPrefix(socketPath, "/") {
		runtimeDir := os.Getenv("XDG_RUNTIME_DIR")
		if runtimeDir == "" {
			return nil, errors.New("XDG_RUNTIME_DIR not set")
		}
		socketPath = filepath.Join(runtimeDir, socketPath)
	}
	
	fd, err := syscall.Socket(syscall.AF_UNIX, syscall.SOCK_STREAM, 0)
	if err != nil {
		return nil, fmt.Errorf("failed to create socket: %w", err)
	}
	
	addr := &syscall.SockaddrUnix{Name: socketPath}
	if err := syscall.Connect(fd, addr); err != nil {
		syscall.Close(fd)
		return nil, fmt.Errorf("failed to connect to Wayland: %w", err)
	}
	
	conn := &Connection{
		fd:      fd,
		objects: make(map[uint32]WaylandObject),
		nextID:  2, // 1 is reserved for wl_display
	}
	
	return conn, nil
}

// Close closes the connection
func (c *Connection) Close() error {
	return syscall.Close(c.fd)
}

// AllocateID allocates a new object ID
func (c *Connection) AllocateID() uint32 {
	c.idMu.Lock()
	defer c.idMu.Unlock()
	
	id := c.nextID
	c.nextID++
	return id
}

// RegisterObject registers a Wayland object
func (c *Connection) RegisterObject(obj WaylandObject) {
	c.objectsMu.Lock()
	defer c.objectsMu.Unlock()
	
	c.objects[obj.ID()] = obj
}

// UnregisterObject unregisters a Wayland object
func (c *Connection) UnregisterObject(id uint32) {
	c.objectsMu.Lock()
	defer c.objectsMu.Unlock()
	
	delete(c.objects, id)
}

// GetObject retrieves a registered object
func (c *Connection) GetObject(id uint32) WaylandObject {
	c.objectsMu.RLock()
	defer c.objectsMu.RUnlock()
	
	return c.objects[id]
}

// SendMessage sends a message to the compositor
func (c *Connection) SendMessage(objectID, opcode uint32, args ...interface{}) error {
	c.sendMu.Lock()
	defer c.sendMu.Unlock()
	
	// Reset buffer
	c.sendBuf.Reset()
	
	// Write header
	header := make([]byte, 8)
	putUint32(header[0:4], objectID)
	size := uint32(8) // header size
	opSize := uint32(opcode&0xffff) << 16
	
	// Calculate message size and write arguments
	argsBuf := &bytes.Buffer{}
	for _, arg := range args {
		if err := c.writeArgument(argsBuf, arg); err != nil {
			return fmt.Errorf("failed to write argument: %w", err)
		}
	}
	
	size += uint32(argsBuf.Len())
	putUint32(header[4:8], size|opSize)
	
	// Write complete message
	c.sendBuf.Write(header)
	c.sendBuf.Write(argsBuf.Bytes())
	
	// Pad to 32-bit boundary
	padding := (4 - (size % 4)) % 4
	if padding > 0 {
		c.sendBuf.Write(make([]byte, padding))
	}
	
	// Send message
	_, err := syscall.Write(c.fd, c.sendBuf.Bytes())
	return err
}

func (c *Connection) writeArgument(buf *bytes.Buffer, arg interface{}) error {
	switch v := arg.(type) {
	case int32:
		b := make([]byte, 4)
		putInt32(b, v)
		buf.Write(b)
	case uint32:
		b := make([]byte, 4)
		putUint32(b, v)
		buf.Write(b)
	case Fixed:
		b := make([]byte, 4)
		putInt32(b, int32(v))
		buf.Write(b)
	case string:
		// Write string length (including null terminator)
		strlen := uint32(len(v) + 1)
		b := make([]byte, 4)
		putUint32(b, strlen)
		buf.Write(b)
		
		// Write string data with null terminator
		buf.WriteString(v)
		buf.WriteByte(0)
		
		// Pad to 32-bit boundary
		padding := (4 - (strlen % 4)) % 4
		if padding > 0 {
			buf.Write(make([]byte, padding))
		}
	case []byte:
		// Write array length
		arrlen := uint32(len(v))
		b := make([]byte, 4)
		putUint32(b, arrlen)
		buf.Write(b)
		
		// Write array data
		buf.Write(v)
		
		// Pad to 32-bit boundary
		padding := (4 - (arrlen % 4)) % 4
		if padding > 0 {
			buf.Write(make([]byte, padding))
		}
	case WaylandObject:
		// Write object ID
		b := make([]byte, 4)
		if v != nil {
			putUint32(b, v.ID())
		} else {
			putUint32(b, 0)
		}
		buf.Write(b)
	default:
		return fmt.Errorf("unsupported argument type: %T", arg)
	}
	
	return nil
}

// ReadMessage reads a message from the compositor
func (c *Connection) ReadMessage() (objectID, opcode uint32, data []byte, err error) {
	c.recvMu.Lock()
	defer c.recvMu.Unlock()
	
	// Read header
	header := make([]byte, 8)
	if _, err := io.ReadFull(c, header); err != nil {
		return 0, 0, nil, err
	}
	
	objectID = getUint32(header[0:4])
	sizeOpcode := getUint32(header[4:8])
	size := sizeOpcode & 0xffff
	opcode = sizeOpcode >> 16
	
	// Read message data
	if size > 8 {
		data = make([]byte, size-8)
		if _, err := io.ReadFull(c, data); err != nil {
			return 0, 0, nil, err
		}
	}
	
	return objectID, opcode, data, nil
}

// Read implements io.Reader
func (c *Connection) Read(p []byte) (n int, err error) {
	return syscall.Read(c.fd, p)
}

// Constants
{{range .Constants}}
const {{.Name}} {{.Type}} = {{.Value}}{{if .Comment}} // {{.Comment}}{{end}}
{{end}}

// Base object implementation
type baseObject struct {
	id        uint32
	conn      *Connection
	version   uint32
	listeners []interface{}
	mu        sync.RWMutex
}

func (o *baseObject) ID() uint32 {
	return o.id
}

func (o *baseObject) SetID(id uint32) {
	o.id = id
}

func (o *baseObject) Version() uint32 {
	return o.version
}

func (o *baseObject) Connection() *Connection {
	return o.conn
}

// Wire format helpers
func putUint32(b []byte, v uint32) {
	b[0] = byte(v)
	b[1] = byte(v >> 8)
	b[2] = byte(v >> 16)
	b[3] = byte(v >> 24)
}

func getUint32(b []byte) uint32 {
	return uint32(b[0]) | uint32(b[1])<<8 | uint32(b[2])<<16 | uint32(b[3])<<24
}

func putInt32(b []byte, v int32) {
	putUint32(b, uint32(v))
}

func getInt32(b []byte) int32 {
	return int32(getUint32(b))
}

{{range .Interfaces}}
// {{.GoName}} represents the {{.Name}} interface (version {{.Version}})
{{if .Description}}// {{.Description}}{{end}}
type {{.GoName}} interface {
	WaylandObject
	
{{range .Requests}}	// {{.GoName}}{{if .Description}} - {{.Description}}{{end}}
	{{.GoName}}({{range $i, $arg := .Args}}{{if $i}}, {{end}}{{.GoName}} {{.GoType}}{{end}}) error
{{end}}
{{range .Events}}	// On{{.GoName}} registers a listener for {{.Name}} events
	On{{.GoName}}(func({{range $i, $arg := .Args}}{{if $i}}, {{end}}{{.GoName}} {{.GoType}}{{end}}))
{{end}}
}

// {{.GoName}}Impl implements {{.GoName}}
type {{.GoName}}Impl struct {
	baseObject
}

// Interface returns the interface name
func (o *{{.GoName}}Impl) Interface() string {
	return "{{.Name}}"
}

{{range .Requests}}
// {{.GoName}} - {{.Description}}
func (o *{{.GoName}}Impl) {{.GoName}}({{range $i, $arg := .Args}}{{if $i}}, {{end}}{{.GoName}} {{.GoType}}{{end}}) error {
	{{if .IsDestructor}}defer o.conn.UnregisterObject(o.id){{end}}
	
	args := []interface{}{
		{{range .Args}}{{if .IsNewID}}{{.GoName}}.ID(){{else}}{{.GoName}}{{end}},
		{{end}}
	}
	
	return o.conn.SendMessage(o.id, {{.Opcode}}, args...)
}
{{end}}

{{range .Events}}
// On{{.GoName}} registers a listener for {{.Name}} events
func (o *{{.GoName}}Impl) On{{.GoName}}(listener func({{range $i, $arg := .Args}}{{if $i}}, {{end}}{{.GoName}} {{.GoType}}{{end}})) {
	o.mu.Lock()
	defer o.mu.Unlock()
	o.listeners = append(o.listeners, listener)
}
{{end}}

{{if .IsManager}}
// New{{.GoName}} creates a new {{.GoName}}
func New{{.GoName}}(conn *Connection, id uint32, version uint32) {{.GoName}} {
	obj := &{{.GoName}}Impl{
		baseObject: baseObject{
			id:      id,
			conn:    conn,
			version: version,
		},
	}
	conn.RegisterObject(obj)
	return obj
}
{{end}}

{{end}}

// Global registry for interface names
var interfaceRegistry = map[string]func(*Connection, uint32, uint32) WaylandObject{
{{range .Interfaces}}{{if .IsManager}}	"{{.Name}}": func(c *Connection, id uint32, v uint32) WaylandObject { return New{{.GoName}}(c, id, v) },
{{end}}{{end}}
}

// CreateObject creates a new object for the given interface
func CreateObject(conn *Connection, iface string, id uint32, version uint32) (WaylandObject, error) {
	factory, ok := interfaceRegistry[iface]
	if !ok {
		return nil, fmt.Errorf("unknown interface: %s", iface)
	}
	return factory(conn, id, version), nil
}
`